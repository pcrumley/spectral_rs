mod common;

use rustfft::num_complex::Complex;
use rustfft::num_traits::Zero;
use spectral_rs::{
    flds::{Fld, Flds, Pos},
    Float,
};

fn init_flds() -> Flds {
    let sim = common::setup_sim();
    assert_eq!(sim.size_x, 24);
    assert_eq!(sim.size_y, 12);
    Flds::new(&sim)
}

#[test]
fn field_init() {
    // checks that all fields are intialized to the correct
    // size and to zero
    let expected_spatial_val: Vec<Float> = vec![0.; (24 + 2) * (12 + 2)];
    let expected_complex_val: Vec<Complex<Float>> = vec![Complex::zero(); 24 * 12];
    let flds = init_flds();
    for fld in &[
        flds.j_x, flds.j_y, flds.j_z, flds.dsty, flds.b_x, flds.b_y, flds.b_z, flds.e_x, flds.e_y,
        flds.e_z,
    ] {
        assert_eq!(fld.spatial.len(), expected_spatial_val.len());
        assert_eq!(fld.spectral.len(), expected_complex_val.len());
        for (v, expected_v) in fld.spatial.iter().zip(expected_spatial_val.iter()) {
            assert_eq!(v, expected_v);
        }
        for (v, expected_v) in fld.spectral.iter().zip(expected_complex_val.iter()) {
            assert_eq!(v, expected_v);
        }
    }
}

#[test]
fn row_major_order() {
    let sim = common::setup_sim();
    // so this function counts the two ghost zones.
    //
    //
    //iterate over rows as outer iter

    let mut index = 0;
    for i in 0..sim.size_y + 2 {
        for j in 0..sim.size_x + 2 {
            assert_eq!(sim.spatial_get_index(Pos { row: i, col: j }), index);
            index += 1;
        }
    }
}

#[test]
fn ghost_deposit() {
    // made an example using google sheets
    let mut input: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.8, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let expected_output: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 4.21, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 3.81, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4,
        1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.41, 1.8, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11,
        1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 4.51, 1.41, 1.41, 1.41, 1.41, 1.41,
        1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81,
        1.81, 1.81, 4.31, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let sim = common::setup_sim();
    assert_eq!(input.len(), expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));
    Flds::deposit_ghosts(&sim, &mut input);
    for (v, expected_v) in input.into_iter().zip(expected_output) {
        assert_eq!(v, expected_v);
    }
}

#[test]
fn ghosts_update() {
    // made an example using google sheets
    let mut input: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.8, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let expected_output: Vec<Float> = vec![
        4.31, 4.51, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81,
        1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 4.31, 4.51, 3.81, 4.21, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 1.31, 1.31, 1.31, 1.31, 3.81, 4.21, 1.41, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.41, 1.81, 1.41, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.41,
        1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.41, 1.81, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11,
        1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 4.31, 4.51, 1.41,
        1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81, 1.81, 1.81, 1.81,
        1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 4.31, 4.51, 3.81, 4.21, 1.11, 1.11, 1.11, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 1.31, 3.81, 4.21,
    ];
    let sim = common::setup_sim();
    assert_eq!(input.len(), expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));
    Flds::deposit_ghosts(&sim, &mut input);
    Flds::update_ghosts(&sim, &mut input);
    for (v, expected_v) in input.into_iter().zip(expected_output) {
        assert_eq!(v, expected_v);
    }
}

#[test]
fn copy_to_spectral() {
    let input: Vec<Float> = vec![
        0.613, 0.751, 0.42, 0.417, 0.09, 0.588, 0.487, 0.109, 0.095, 0.572, 0.527, 0.671, 0.567,
        0.438, 0.538, 0.642, 0.244, 0.773, 0.639, 0.146, 0.689, 0.292, 0.728, 0.055, 0.72, 0.453,
        0.838, 0.041, 0.324, 0.237, 0.616, 0.183, 0.916, 0.207, 0.985, 0.021, 0.554, 0.49, 0.113,
        0.941, 0.335, 0.922, 0.245, 0.31, 0.746, 0.414, 0.853, 0.081, 0.17, 0.532, 0.802, 0.447,
        0.112, 0.411, 0.919, 0.702, 0.959, 0.357, 0.431, 0.694, 0.236, 0.94, 0.235, 0.096, 0.42,
        0.931, 0.843, 0.281, 0.306, 0.191, 0.168, 0.759, 0.834, 0.472, 0.997, 0.954, 0.05, 0.189,
        0.147, 0.653, 0.583, 0.364, 0.786, 0.53, 0.599, 0.334, 0.346, 0.048, 0.718, 0.326, 0.792,
        0.423, 0.779, 0.655, 0.731, 0.527, 0.656, 0.138, 0.015, 0.336, 0.56, 0.3, 0.023, 0.985,
        0.38, 0.077, 0.772, 0.587, 0.661, 0.022, 0.383, 0.704, 0.754, 0.465, 0.175, 0.771, 0.534,
        0.693, 0.859, 0.842, 0.807, 0.963, 0.875, 0.716, 0.233, 0.103, 0.904, 0.909, 0.112, 0.506,
        0.993, 0.936, 0.891, 0.572, 0.514, 0.064, 0.613, 0.034, 0.413, 0.047, 0.806, 0.143, 0.785,
        0.323, 0.527, 0.401, 0.868, 0.847, 0.36, 0.371, 0.943, 1.0, 0.16, 0.115, 0.487, 0.015,
        0.277, 0.984, 0.143, 0.965, 0.779, 0.796, 0.735, 0.639, 0.941, 0.931, 0.594, 0.563, 0.881,
        0.507, 0.922, 0.035, 0.773, 0.59, 0.802, 0.253, 0.488, 0.345, 0.697, 0.555, 0.903, 0.149,
        0.995, 0.323, 0.316, 0.931, 0.219, 0.342, 0.623, 0.441, 0.014, 0.246, 0.944, 0.714, 0.919,
        0.249, 0.363, 0.738, 0.238, 0.516, 0.347, 0.205, 0.027, 0.369, 0.171, 0.287, 0.328, 0.05,
        0.386, 0.564, 0.304, 0.881, 0.947, 0.6, 0.856, 0.48, 0.15, 0.162, 0.636, 0.185, 0.908,
        0.765, 0.103, 0.916, 0.236, 0.026, 0.43, 0.513, 0.029, 0.313, 0.596, 0.025, 0.344, 0.307,
        0.987, 0.485, 0.446, 0.382, 0.165, 0.496, 0.799, 0.164, 0.26, 0.315, 0.059, 0.233, 0.587,
        0.221, 0.856, 0.711, 0.705, 0.623, 0.824, 0.356, 0.107, 0.79, 0.913, 0.923, 0.117, 0.059,
        0.471, 0.706, 0.397, 0.111, 0.985, 0.641, 0.651, 0.201, 0.64, 0.828, 0.739, 0.258, 0.057,
        0.073, 0.437, 0.423, 0.667, 0.894, 0.496, 0.858, 0.179, 0.436, 0.486, 0.707, 0.517, 0.927,
        0.173, 0.618, 0.416, 0.632, 0.783, 0.59, 0.591, 0.717, 0.601, 0.809, 0.016, 0.109, 0.77,
        0.71, 0.406, 0.213, 0.065, 0.804, 0.407, 0.285, 0.633, 0.657, 0.38, 0.405, 0.421, 0.987,
        0.893, 0.202, 0.063, 0.092, 0.214, 0.965, 0.49, 0.622, 0.155, 0.285, 0.435, 0.328, 0.602,
        0.165, 0.301, 0.516, 0.923, 0.365, 0.558, 0.845, 0.269, 0.848, 0.967, 0.559, 0.434, 0.347,
        0.438, 0.429, 0.568, 0.462, 0.252, 0.46, 0.536, 0.184, 0.727, 0.912, 0.116, 0.436, 0.129,
        0.283, 0.556, 0.029, 0.781, 0.703, 0.234, 0.411, 0.881, 0.595, 0.29, 0.74, 0.494, 0.578,
    ];
    let expected_output: Vec<Float> = vec![
        0.041, 0.324, 0.237, 0.616, 0.183, 0.916, 0.207, 0.985, 0.021, 0.554, 0.49, 0.113, 0.941,
        0.335, 0.922, 0.245, 0.31, 0.746, 0.414, 0.853, 0.081, 0.17, 0.532, 0.802, 0.411, 0.919,
        0.702, 0.959, 0.357, 0.431, 0.694, 0.236, 0.94, 0.235, 0.096, 0.42, 0.931, 0.843, 0.281,
        0.306, 0.191, 0.168, 0.759, 0.834, 0.472, 0.997, 0.954, 0.05, 0.653, 0.583, 0.364, 0.786,
        0.53, 0.599, 0.334, 0.346, 0.048, 0.718, 0.326, 0.792, 0.423, 0.779, 0.655, 0.731, 0.527,
        0.656, 0.138, 0.015, 0.336, 0.56, 0.3, 0.023, 0.077, 0.772, 0.587, 0.661, 0.022, 0.383,
        0.704, 0.754, 0.465, 0.175, 0.771, 0.534, 0.693, 0.859, 0.842, 0.807, 0.963, 0.875, 0.716,
        0.233, 0.103, 0.904, 0.909, 0.112, 0.936, 0.891, 0.572, 0.514, 0.064, 0.613, 0.034, 0.413,
        0.047, 0.806, 0.143, 0.785, 0.323, 0.527, 0.401, 0.868, 0.847, 0.36, 0.371, 0.943, 1.0,
        0.16, 0.115, 0.487, 0.984, 0.143, 0.965, 0.779, 0.796, 0.735, 0.639, 0.941, 0.931, 0.594,
        0.563, 0.881, 0.507, 0.922, 0.035, 0.773, 0.59, 0.802, 0.253, 0.488, 0.345, 0.697, 0.555,
        0.903, 0.323, 0.316, 0.931, 0.219, 0.342, 0.623, 0.441, 0.014, 0.246, 0.944, 0.714, 0.919,
        0.249, 0.363, 0.738, 0.238, 0.516, 0.347, 0.205, 0.027, 0.369, 0.171, 0.287, 0.328, 0.564,
        0.304, 0.881, 0.947, 0.6, 0.856, 0.48, 0.15, 0.162, 0.636, 0.185, 0.908, 0.765, 0.103,
        0.916, 0.236, 0.026, 0.43, 0.513, 0.029, 0.313, 0.596, 0.025, 0.344, 0.485, 0.446, 0.382,
        0.165, 0.496, 0.799, 0.164, 0.26, 0.315, 0.059, 0.233, 0.587, 0.221, 0.856, 0.711, 0.705,
        0.623, 0.824, 0.356, 0.107, 0.79, 0.913, 0.923, 0.117, 0.706, 0.397, 0.111, 0.985, 0.641,
        0.651, 0.201, 0.64, 0.828, 0.739, 0.258, 0.057, 0.073, 0.437, 0.423, 0.667, 0.894, 0.496,
        0.858, 0.179, 0.436, 0.486, 0.707, 0.517, 0.618, 0.416, 0.632, 0.783, 0.59, 0.591, 0.717,
        0.601, 0.809, 0.016, 0.109, 0.77, 0.71, 0.406, 0.213, 0.065, 0.804, 0.407, 0.285, 0.633,
        0.657, 0.38, 0.405, 0.421, 0.202, 0.063, 0.092, 0.214, 0.965, 0.49, 0.622, 0.155, 0.285,
        0.435, 0.328, 0.602, 0.165, 0.301, 0.516, 0.923, 0.365, 0.558, 0.845, 0.269, 0.848, 0.967,
        0.559, 0.434,
    ];

    let sim = common::setup_sim();
    assert_eq!(sim.size_x * sim.size_y, expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));

    let mut test_fld = Fld {
        spatial: input.clone(),
        spectral: vec![Complex::zero(); sim.size_x * sim.size_y],
    };

    test_fld.copy_to_spectral(&sim);

    for (v1, v2) in test_fld.spatial.iter().zip(input) {
        assert_eq!(*v1, v2);
    }

    for (v1, v2) in test_fld.spectral.iter().zip(expected_output) {
        assert_eq!(v1.re, v2);
        assert_eq!(v1.im, 0.0);
    }
}
