mod common;

use rustfft::num_complex::Complex;
use rustfft::num_traits::Zero;
use spectral_rs::{
    flds::{Fld, Flds, Pos},
    Float,
};

fn init_flds() -> Flds {
    let sim = common::setup_sim();
    assert_eq!(sim.size_x, 24);
    assert_eq!(sim.size_y, 12);
    Flds::new(&sim)
}

#[test]
fn field_init() {
    // checks that all fields are intialized to the correct
    // size and to zero
    let expected_spatial_val: Vec<Float> = vec![0.; (24 + 2) * (12 + 2)];
    let expected_complex_val: Vec<Complex<Float>> = vec![Complex::zero(); 24 * 12];
    let flds = init_flds();
    for fld in &[
        flds.j_x, flds.j_y, flds.j_z, flds.dsty, flds.b_x, flds.b_y, flds.b_z, flds.e_x, flds.e_y,
        flds.e_z,
    ] {
        assert_eq!(fld.spatial.len(), expected_spatial_val.len());
        assert_eq!(fld.spectral.len(), expected_complex_val.len());
        for (v, expected_v) in fld.spatial.iter().zip(expected_spatial_val.iter()) {
            assert_eq!(v, expected_v);
        }
        for (v, expected_v) in fld.spectral.iter().zip(expected_complex_val.iter()) {
            assert_eq!(v, expected_v);
        }
    }
}

#[test]
fn row_major_order() {
    let sim = common::setup_sim();
    // so this function counts the two ghost zones.
    //
    //
    //iterate over rows as outer iter

    let mut index = 0;
    for i in 0..sim.size_y + 2 {
        for j in 0..sim.size_x + 2 {
            assert_eq!(sim.spatial_get_index(Pos { row: i, col: j }), index);
            index += 1;
        }
    }
}

#[test]
fn ghost_deposit() {
    // made an example using google sheets
    let mut input: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.8, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let expected_output: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 4.21, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 3.81, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4,
        1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.41, 1.8, 1.4, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.41, 1.8, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11,
        1.3, 1.1, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 1.31, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.3, 1.1, 4.51, 1.41, 1.41, 1.41, 1.41, 1.41,
        1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81,
        1.81, 1.81, 4.31, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let sim = common::setup_sim();
    assert_eq!(input.len(), expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));
    Flds::deposit_ghosts(&sim, &mut input);
    for (v, expected_v) in input.into_iter().zip(expected_output) {
        assert_eq!(v, expected_v);
    }
}

#[test]
fn ghosts_update() {
    // made an example using google sheets
    let mut input: Vec<Float> = vec![
        1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.4, 1.8, 1.8, 1.8, 1.8, 1.8,
        1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 1.8, 1.4, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.8, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.3, 1.1, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.3, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1,
        1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,
    ];
    let expected_output: Vec<Float> = vec![
        4.31, 4.51, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81,
        1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 4.31, 4.51, 3.81, 4.21, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 1.31, 1.31, 1.31, 1.31, 3.81, 4.21, 1.41, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 1.41, 1.81, 1.41, 1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.41,
        1.81, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.41, 1.81, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 1.41, 1.81, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 1.11, 1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11,
        1.31, 1.11, 1.31, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,
        0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 1.11, 1.31, 4.31, 4.51, 1.41,
        1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.41, 1.81, 1.81, 1.81, 1.81, 1.81,
        1.81, 1.81, 1.81, 1.81, 1.81, 1.81, 4.31, 4.51, 3.81, 4.21, 1.11, 1.11, 1.11, 1.11, 1.11,
        1.11, 1.11, 1.11, 1.11, 1.11, 1.11, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31, 1.31,
        1.31, 1.31, 3.81, 4.21,
    ];
    let sim = common::setup_sim();
    assert_eq!(input.len(), expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));
    Flds::deposit_ghosts(&sim, &mut input);
    Flds::update_ghosts(&sim, &mut input);
    for (v, expected_v) in input.into_iter().zip(expected_output) {
        assert_eq!(v, expected_v);
    }
}

#[test]
fn copy_to_spectral() {
    let input: Vec<Float> = vec![
        0.668, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894, 0.856, 0.794, 0.354,
        0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945, 0.832, 0.668, 0.157,
        0.46, 0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863,
        0.605, 0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.691,
        0.804, 0.747, 0.437, 0.773, 0.584, 0.681, 0.766, 0.732, 0.477, 0.565, 0.517, 0.923, 0.757,
        0.3, 0.186, 0.759, 0.973, 0.927, 0.962, 0.389, 0.963, 0.339, 0.778, 0.496, 0.804, 0.747,
        0.143, 0.354, 0.301, 0.766, 0.203, 0.587, 0.462, 0.571, 0.496, 0.68, 0.664, 0.994, 0.608,
        0.713, 0.446, 0.324, 0.421, 0.987, 0.195, 0.56, 0.486, 0.149, 0.255, 0.562, 0.143, 0.354,
        0.818, 0.965, 0.691, 0.399, 0.953, 0.997, 0.035, 0.928, 0.277, 0.442, 0.05, 0.254, 0.784,
        0.345, 0.26, 0.759, 0.113, 0.699, 0.268, 0.867, 0.613, 0.271, 0.789, 0.83, 0.818, 0.965,
        0.16, 0.701, 0.182, 0.335, 0.959, 0.013, 0.915, 0.598, 0.777, 0.441, 0.437, 0.582, 0.897,
        0.32, 0.584, 0.824, 0.698, 0.214, 0.442, 0.708, 0.384, 0.862, 0.377, 0.359, 0.16, 0.701,
        0.319, 0.943, 0.947, 0.126, 0.481, 0.483, 0.967, 0.187, 0.297, 0.069, 0.283, 0.513, 0.669,
        0.314, 0.583, 0.992, 0.934, 0.24, 0.3, 0.39, 0.307, 0.353, 0.44, 0.752, 0.319, 0.943,
        0.368, 0.099, 0.049, 0.273, 0.062, 0.01, 0.702, 0.158, 0.526, 0.674, 0.101, 0.252, 0.963,
        0.661, 0.747, 0.474, 0.906, 0.215, 0.188, 0.375, 0.496, 0.103, 0.596, 0.228, 0.368, 0.099,
        0.472, 0.906, 0.096, 0.486, 0.533, 0.181, 0.235, 0.905, 0.862, 0.44, 0.62, 0.655, 0.024,
        0.513, 0.748, 0.533, 0.209, 0.246, 0.706, 0.631, 0.112, 0.693, 0.379, 0.576, 0.472, 0.906,
        0.997, 0.728, 0.439, 0.416, 0.301, 0.071, 0.287, 0.946, 0.211, 0.664, 0.394, 0.532, 0.588,
        0.368, 0.924, 0.771, 0.102, 0.24, 0.13, 0.12, 0.955, 0.407, 0.741, 0.73, 0.997, 0.728,
        0.74, 0.115, 0.109, 0.455, 0.355, 0.302, 0.364, 0.207, 0.988, 0.158, 0.03, 0.498, 0.931,
        0.92, 0.485, 0.698, 0.601, 0.568, 0.743, 0.794, 0.2, 0.553, 0.392, 0.552, 0.74, 0.115,
        0.238, 0.277, 0.092, 0.747, 0.361, 0.072, 0.778, 0.428, 0.702, 0.811, 0.116, 0.666, 0.155,
        0.987, 0.163, 0.411, 0.124, 0.499, 0.861, 0.911, 0.468, 0.959, 0.705, 0.724, 0.238, 0.277,
        0.668, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894, 0.856, 0.794, 0.354,
        0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945, 0.832, 0.668, 0.157,
        0.46, 0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863,
        0.605, 0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.691,
    ];
    let expected_output: Vec<Float> = vec![
        0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863, 0.605,
        0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.747, 0.437,
        0.773, 0.584, 0.681, 0.766, 0.732, 0.477, 0.565, 0.517, 0.923, 0.757, 0.3, 0.186, 0.759,
        0.973, 0.927, 0.962, 0.389, 0.963, 0.339, 0.778, 0.496, 0.804, 0.354, 0.301, 0.766, 0.203,
        0.587, 0.462, 0.571, 0.496, 0.68, 0.664, 0.994, 0.608, 0.713, 0.446, 0.324, 0.421, 0.987,
        0.195, 0.56, 0.486, 0.149, 0.255, 0.562, 0.143, 0.965, 0.691, 0.399, 0.953, 0.997, 0.035,
        0.928, 0.277, 0.442, 0.05, 0.254, 0.784, 0.345, 0.26, 0.759, 0.113, 0.699, 0.268, 0.867,
        0.613, 0.271, 0.789, 0.83, 0.818, 0.701, 0.182, 0.335, 0.959, 0.013, 0.915, 0.598, 0.777,
        0.441, 0.437, 0.582, 0.897, 0.32, 0.584, 0.824, 0.698, 0.214, 0.442, 0.708, 0.384, 0.862,
        0.377, 0.359, 0.16, 0.943, 0.947, 0.126, 0.481, 0.483, 0.967, 0.187, 0.297, 0.069, 0.283,
        0.513, 0.669, 0.314, 0.583, 0.992, 0.934, 0.24, 0.3, 0.39, 0.307, 0.353, 0.44, 0.752,
        0.319, 0.099, 0.049, 0.273, 0.062, 0.01, 0.702, 0.158, 0.526, 0.674, 0.101, 0.252, 0.963,
        0.661, 0.747, 0.474, 0.906, 0.215, 0.188, 0.375, 0.496, 0.103, 0.596, 0.228, 0.368, 0.906,
        0.096, 0.486, 0.533, 0.181, 0.235, 0.905, 0.862, 0.44, 0.62, 0.655, 0.024, 0.513, 0.748,
        0.533, 0.209, 0.246, 0.706, 0.631, 0.112, 0.693, 0.379, 0.576, 0.472, 0.728, 0.439, 0.416,
        0.301, 0.071, 0.287, 0.946, 0.211, 0.664, 0.394, 0.532, 0.588, 0.368, 0.924, 0.771, 0.102,
        0.24, 0.13, 0.12, 0.955, 0.407, 0.741, 0.73, 0.997, 0.115, 0.109, 0.455, 0.355, 0.302,
        0.364, 0.207, 0.988, 0.158, 0.03, 0.498, 0.931, 0.92, 0.485, 0.698, 0.601, 0.568, 0.743,
        0.794, 0.2, 0.553, 0.392, 0.552, 0.74, 0.277, 0.092, 0.747, 0.361, 0.072, 0.778, 0.428,
        0.702, 0.811, 0.116, 0.666, 0.155, 0.987, 0.163, 0.411, 0.124, 0.499, 0.861, 0.911, 0.468,
        0.959, 0.705, 0.724, 0.238, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894,
        0.856, 0.794, 0.354, 0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945,
        0.832, 0.668,
    ];

    let sim = common::setup_sim();
    assert_eq!(sim.size_x * sim.size_y, expected_output.len());
    assert_eq!(input.len(), (sim.size_x + 2) * (sim.size_y + 2));

    let mut test_fld = Fld {
        spatial: input.clone(),
        spectral: vec![Complex::zero(); sim.size_x * sim.size_y],
    };

    test_fld.copy_to_spectral(&sim);

    for (v1, v2) in test_fld.spatial.iter().zip(input) {
        assert_eq!(*v1, v2);
    }

    for (v1, v2) in test_fld.spectral.iter().zip(expected_output) {
        assert_eq!(v1.re, v2);
        assert_eq!(v1.im, 0.0);
    }
}

#[test]
fn copy_to_spatial() {
    let expected_output: Vec<Float> = vec![
        0.668, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894, 0.856, 0.794, 0.354,
        0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945, 0.832, 0.668, 0.157,
        0.46, 0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863,
        0.605, 0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.691,
        0.804, 0.747, 0.437, 0.773, 0.584, 0.681, 0.766, 0.732, 0.477, 0.565, 0.517, 0.923, 0.757,
        0.3, 0.186, 0.759, 0.973, 0.927, 0.962, 0.389, 0.963, 0.339, 0.778, 0.496, 0.804, 0.747,
        0.143, 0.354, 0.301, 0.766, 0.203, 0.587, 0.462, 0.571, 0.496, 0.68, 0.664, 0.994, 0.608,
        0.713, 0.446, 0.324, 0.421, 0.987, 0.195, 0.56, 0.486, 0.149, 0.255, 0.562, 0.143, 0.354,
        0.818, 0.965, 0.691, 0.399, 0.953, 0.997, 0.035, 0.928, 0.277, 0.442, 0.05, 0.254, 0.784,
        0.345, 0.26, 0.759, 0.113, 0.699, 0.268, 0.867, 0.613, 0.271, 0.789, 0.83, 0.818, 0.965,
        0.16, 0.701, 0.182, 0.335, 0.959, 0.013, 0.915, 0.598, 0.777, 0.441, 0.437, 0.582, 0.897,
        0.32, 0.584, 0.824, 0.698, 0.214, 0.442, 0.708, 0.384, 0.862, 0.377, 0.359, 0.16, 0.701,
        0.319, 0.943, 0.947, 0.126, 0.481, 0.483, 0.967, 0.187, 0.297, 0.069, 0.283, 0.513, 0.669,
        0.314, 0.583, 0.992, 0.934, 0.24, 0.3, 0.39, 0.307, 0.353, 0.44, 0.752, 0.319, 0.943,
        0.368, 0.099, 0.049, 0.273, 0.062, 0.01, 0.702, 0.158, 0.526, 0.674, 0.101, 0.252, 0.963,
        0.661, 0.747, 0.474, 0.906, 0.215, 0.188, 0.375, 0.496, 0.103, 0.596, 0.228, 0.368, 0.099,
        0.472, 0.906, 0.096, 0.486, 0.533, 0.181, 0.235, 0.905, 0.862, 0.44, 0.62, 0.655, 0.024,
        0.513, 0.748, 0.533, 0.209, 0.246, 0.706, 0.631, 0.112, 0.693, 0.379, 0.576, 0.472, 0.906,
        0.997, 0.728, 0.439, 0.416, 0.301, 0.071, 0.287, 0.946, 0.211, 0.664, 0.394, 0.532, 0.588,
        0.368, 0.924, 0.771, 0.102, 0.24, 0.13, 0.12, 0.955, 0.407, 0.741, 0.73, 0.997, 0.728,
        0.74, 0.115, 0.109, 0.455, 0.355, 0.302, 0.364, 0.207, 0.988, 0.158, 0.03, 0.498, 0.931,
        0.92, 0.485, 0.698, 0.601, 0.568, 0.743, 0.794, 0.2, 0.553, 0.392, 0.552, 0.74, 0.115,
        0.238, 0.277, 0.092, 0.747, 0.361, 0.072, 0.778, 0.428, 0.702, 0.811, 0.116, 0.666, 0.155,
        0.987, 0.163, 0.411, 0.124, 0.499, 0.861, 0.911, 0.468, 0.959, 0.705, 0.724, 0.238, 0.277,
        0.668, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894, 0.856, 0.794, 0.354,
        0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945, 0.832, 0.668, 0.157,
        0.46, 0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863,
        0.605, 0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.691,
    ];

    let input: Vec<Float> = vec![
        0.691, 0.675, 0.495, 0.024, 0.207, 0.413, 0.254, 0.123, 0.131, 0.814, 0.18, 0.863, 0.605,
        0.946, 0.994, 0.949, 0.06, 0.644, 0.651, 0.6, 0.89, 0.206, 0.893, 0.46, 0.747, 0.437,
        0.773, 0.584, 0.681, 0.766, 0.732, 0.477, 0.565, 0.517, 0.923, 0.757, 0.3, 0.186, 0.759,
        0.973, 0.927, 0.962, 0.389, 0.963, 0.339, 0.778, 0.496, 0.804, 0.354, 0.301, 0.766, 0.203,
        0.587, 0.462, 0.571, 0.496, 0.68, 0.664, 0.994, 0.608, 0.713, 0.446, 0.324, 0.421, 0.987,
        0.195, 0.56, 0.486, 0.149, 0.255, 0.562, 0.143, 0.965, 0.691, 0.399, 0.953, 0.997, 0.035,
        0.928, 0.277, 0.442, 0.05, 0.254, 0.784, 0.345, 0.26, 0.759, 0.113, 0.699, 0.268, 0.867,
        0.613, 0.271, 0.789, 0.83, 0.818, 0.701, 0.182, 0.335, 0.959, 0.013, 0.915, 0.598, 0.777,
        0.441, 0.437, 0.582, 0.897, 0.32, 0.584, 0.824, 0.698, 0.214, 0.442, 0.708, 0.384, 0.862,
        0.377, 0.359, 0.16, 0.943, 0.947, 0.126, 0.481, 0.483, 0.967, 0.187, 0.297, 0.069, 0.283,
        0.513, 0.669, 0.314, 0.583, 0.992, 0.934, 0.24, 0.3, 0.39, 0.307, 0.353, 0.44, 0.752,
        0.319, 0.099, 0.049, 0.273, 0.062, 0.01, 0.702, 0.158, 0.526, 0.674, 0.101, 0.252, 0.963,
        0.661, 0.747, 0.474, 0.906, 0.215, 0.188, 0.375, 0.496, 0.103, 0.596, 0.228, 0.368, 0.906,
        0.096, 0.486, 0.533, 0.181, 0.235, 0.905, 0.862, 0.44, 0.62, 0.655, 0.024, 0.513, 0.748,
        0.533, 0.209, 0.246, 0.706, 0.631, 0.112, 0.693, 0.379, 0.576, 0.472, 0.728, 0.439, 0.416,
        0.301, 0.071, 0.287, 0.946, 0.211, 0.664, 0.394, 0.532, 0.588, 0.368, 0.924, 0.771, 0.102,
        0.24, 0.13, 0.12, 0.955, 0.407, 0.741, 0.73, 0.997, 0.115, 0.109, 0.455, 0.355, 0.302,
        0.364, 0.207, 0.988, 0.158, 0.03, 0.498, 0.931, 0.92, 0.485, 0.698, 0.601, 0.568, 0.743,
        0.794, 0.2, 0.553, 0.392, 0.552, 0.74, 0.277, 0.092, 0.747, 0.361, 0.072, 0.778, 0.428,
        0.702, 0.811, 0.116, 0.666, 0.155, 0.987, 0.163, 0.411, 0.124, 0.499, 0.861, 0.911, 0.468,
        0.959, 0.705, 0.724, 0.238, 0.157, 0.249, 0.448, 0.762, 0.348, 0.242, 0.282, 0.41, 0.894,
        0.856, 0.794, 0.354, 0.925, 0.563, 0.65, 0.341, 0.798, 0.223, 0.608, 0.427, 0.102, 0.945,
        0.832, 0.668,
    ];

    let sim = common::setup_sim();
    assert_eq!(sim.size_x * sim.size_y, input.len());
    assert_eq!(expected_output.len(), (sim.size_x + 2) * (sim.size_y + 2));

    let mut test_fld = Fld {
        spatial: vec![0.0; expected_output.len()],
        spectral: vec![Complex::zero(); sim.size_x * sim.size_y],
    };

    for (v1, v2) in test_fld.spectral.iter_mut().zip(input) {
        v1.re = v2;
    }

    test_fld.copy_to_spatial(&sim);
    assert_eq!(expected_output.len(), test_fld.spatial.len());

    for (v1, v2) in test_fld.spatial.iter().zip(expected_output) {
        assert_eq!(*v1, v2);
    }
}
